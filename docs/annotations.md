# Annotations

The following describes how the source code of the recompilation can be annotated such that `reccmp` can compare the recompilation to the original binary.

All annotations are of the form
```c++
// <annotation type>: <target> <address>
```
For example,
```c++
// FUNCTION: LEGO1 0x100b12c0
```
refers to a function at address `0x100b12c0` in the build target aliased by `LEGO1` (since it is possible to build different targets from the same source code).


## Functions

Functions can be annotated by one of the markers below. Each marker contains the address of the function as found in the original binaries. These information are then used to compare the recompiled assembly with the original assembly, resulting in an accuracy score.

Note that functions in a given compilation unit must be ordered by their address in ascending order.

Function annotations can have multiple different types, which are explained below.

There are three ways to annotate a function:

### Annotating the implementation
The preferable way is to annotate the implementation directly. For example:
```c++
// FUNCTION: LEGO1 0x100b12c0
MxCore* MxObjectFactory::Create(const char* p_name)
{
  // implementation
}
```

### Annotating a comment of the function name

There are situations where the previous kind of annotation is not possible. Typical examples are:
- templated functions
- synthetic functions (generated by the compiler)
- library functions (like the C++ standard library)
- non-inlined inline functions

In those cases, one can spell out the function's name in a comment:
```c++
// TEMPLATE: LEGO1 0x100c4f50
// MxCollection<MxRegionLeftRight *>::`scalar deleting destructor'
```

### Annotating a comment of the function's symbol

There are a few cases where two functions of the same name need to be annotated by comment (e.g. in function overloads). In such cases, you can annotate a comment of the function's debug symbol:
```c++
// TEMPLATE: LEGO1 0x10035790
// ?_Construct@@YAXPAPAVROI@@ABQAV1@@Z
```

### Annotation types

#### `FUNCTION`

Functions with a reasonably complete implementation which are not templated or synthetic (see below) should be annotated with `FUNCTION`. It is preferable to annotate the function's implementation directly.

#### `STUB`

Functions with no or a very incomplete implementation should be annotated with `STUB`. These will not be compared to the original assembly.

```c++
// STUB: LEGO1 0x10011d50
LegoCameraController::LegoCameraController()
{
  // TODO
}
```

#### `TEMPLATE`

Templated functions should be annotated with `TEMPLATE`. Since the goal is to eventually have a full accounting of all the functions present in the binaries, please make an effort to find and annotate every function of a templated class.

```c++
// TEMPLATE: LEGO1 0x100c0ee0
// list<MxNextActionDataStart *,allocator<MxNextActionDataStart *> >::_Buynode

// TEMPLATE: LEGO1 0x100c0fc0
// MxStreamListMxDSSubscriber::~MxStreamListMxDSSubscriber

// TEMPLATE: LEGO1 0x100c1010
// MxStreamListMxDSAction::~MxStreamListMxDSAction
```

#### `SYNTHETIC`

Synthetic functions should be annotated with `SYNTHETIC`. A synthetic function is generated by the compiler; most common is the "scalar deleting destructor" found in virtual tables. Other cases include default destructors and assignment operators. Note: `SYNTHETIC` takes precedence over `TEMPLATE`.

```c++
// SYNTHETIC: LEGO1 0x10003210
// Helicopter::`scalar deleting destructor'

// SYNTHETIC: LEGO1 0x100c4f50
// MxCollection<MxRegionLeftRight *>::`scalar deleting destructor'

// SYNTHETIC: LEGO1 0x100c4fc0
// MxList<MxRegionLeftRight *>::`scalar deleting destructor'
```

#### `LIBRARY`

Functions located in 3rd party libraries should be annotated with `LIBRARY`. This can be useful for working towards a full accounting of all the functions present in the binaries.

```c++
// LIBRARY: ISLE 0x4061b0
// _MemPoolInit@4

// LIBRARY: ISLE 0x406520
// _MemPoolSetPageSize@8

// LIBRARY: ISLE 0x406630
// _MemPoolSetBlockSizeFS@8
```


## Virtual tables

Classes with a virtual table should be annotated using the `VTABLE` marker, which includes the module name and address of the virtual table:
```c++
// VTABLE: LEGO1 0x100dc900
class MxEventManager : public MxMediaManager {
public:
	MxEventManager();
	virtual ~MxEventManager() override;

	virtual void Destroy() override;                                     // vtable+0x18
	virtual MxResult Create(MxU32 p_frequencyMS, MxBool p_createThread); // vtable+0x28
    // ...
}
```
While not relevant to the `reccmp` scripts, we made a rule in [isledecomp](https://github.com/isledecomp/isle) to annotate functions with a comment indicating their relative offset for convenience.



## Class size

**TODO: Is any of this relevant to reccmp or only to isledecomp?**

Classes should be annotated using the `SIZE` marker to indicate their size. If you are unsure about the class size in the original binary, please use the currently available information (known member variables) and detail the circumstances in an extra comment if necessary.

```c++
// SIZE 0x1c
class MxCriticalSection {
public:
	MxCriticalSection();
	~MxCriticalSection();
	static void SetDoMutex();
    // ...
}
```

Furthermore, add `DECOMP_SIZE_ASSERT(MxCriticalSection, 0x1c)` to the respective `.cpp` file (if the class has no dedicated `.cpp` file, use any appropriate `.cpp` file where the class is used).

## Member variables

**TODO: Is any of this relevant to reccmp or only to isledecomp?**

Member variables should be annotated with their relative offsets.

```c++
class MxDSObject : public MxCore {
private:
	MxU32 m_sizeOnDisk;   // 0x8
	MxU16 m_type;         // 0xc
	char* m_sourceName;   // 0x10
	undefined4 m_unk0x14; // 0x14
    // ...
}
```

## Global variables

Global variables should be annotated using the `GLOBAL` marker, which includes the module name and address of the variable.

```c++
// GLOBAL: LEGO1 0x100f456c
MxAtomId* g_jukeboxScript = NULL;

// GLOBAL: LEGO1 0x100f4570
MxAtomId* g_pz5Script = NULL;

// GLOBAL: LEGO1 0x100f4574
MxAtomId* g_introScript = NULL;
```

## Strings

String values should be annotated using the `STRING` marker, which includes the module name and address of the string. Note that this is usually not required since most strings can be auto-detected. If you want, you can use this for bookeeping, but it will usually not affect the `reccmp` match.

```c++
inline virtual const char* ClassName() const override // vtable+0x0c
{
	// STRING: LEGO1 0x100f03fc
	return "Act2PoliceStation";
}
```